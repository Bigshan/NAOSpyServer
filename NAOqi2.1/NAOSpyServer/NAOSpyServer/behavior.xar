<?xml version="1.0" encoding="UTF-8" ?>
<ChoregrapheProject xmlns="http://www.aldebaran-robotics.com/schema/choregraphe/project.xsd" xar_version="3">
    <Box name="root" id="-1" localization="8" tooltip="Root box of Choregraphe&apos;s project. Highest level possible." x="0" y="0">
        <bitmap>media/images/box/root.png</bitmap>
        <script language="4">
            <content>
                <![CDATA[]]>
</content>
        </script>
        <Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" />
        <Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" />
        <Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" />
        <Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="指令盒行为结束时，送出信号。" id="4" />
        <Timeline enable="0">
            <BehaviorLayer name="behavior_layer1">
                <BehaviorKeyframe name="keyframe1" index="1">
                    <Diagram>
                        <Box name="NAOSpyServer" id="3" localization="8" tooltip="version 2.0.0" x="276" y="127">
                            <bitmap>media/images/box/box-diagram.png</bitmap>
                            <script language="4">
                                <content>
                                    <![CDATA[]]>
</content>
                            </script>
                            <Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" />
                            <Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" />
                            <Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" />
                            <Timeline enable="1" fps="25" start_frame="1" end_frame="-1" size="-1">
                                <BehaviorLayer name="TCPServer">
                                    <BehaviorKeyframe name="TCPServer" index="1">
                                        <Diagram>
                                            <Box name="TCPServer" id="2" localization="8" tooltip="TCPServer" x="173" y="87">
                                                <bitmap>media/images/box/box-python-script.png</bitmap>
                                                <script language="4">
                                                    <content>
                                                        <![CDATA[
from SocketServer import ThreadingTCPServer,BaseRequestHandler
import json
import base64
import threading
import socket
import sys


myTCPServer = None
packageManager =  ALProxy("PackageManager")
managerProxy = ALProxy("ALBehaviorManager")

KHeaderStr = "$$qishanshi$$"
kEndStr = "\r\n"


class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self)
        reload(sys)
        sys.setdefaultencoding('utf-8')
        self.memory = ALProxy("ALMemory")
    def onLoad(self):
        pass

    def onUnload(self):
        stopTCPServer()


    def onInput_onStart(self):
        global myTCPServer
        self.getParentTimeline().pause()

        port = getTCPPort(47355)
        self.memory.insertData("NAOSPY_TCPPORT",port)
        self.logger.info("TCP Server Port:%d",port)

        myTCPServer.serve_forever()

    def onInput_onStop(self):
        self.onUnload()

class MyTCPHandler(BaseRequestHandler):
    def handle(self):
        while 1:
            self.data = self.request.recv(1024).strip()
            recvDic = {}
            try:
                recvDic = json_loads_byteified(self.data)
            except Exception as e:
                break
            path = recvDic["path"]
            if path == "TCP--DisConnect":
                break
            else:
                self.ActionWithDic(recvDic)
    def ActionWithDic(self, dic):
        path = dic["path"]
        if path == "packageIcon":
            uuid = dic["uuid"]
            icon = packageManager.packageIcon(uuid)
            if len(icon) > 0:

                baseDic = {"ContentType":"Image","ContentLength":str(len(icon))}
                jsonStr = json.dumps(baseDic,separators=(',',':'))
                header = KHeaderStr + jsonStr + kEndStr
                self.request.sendall(header)
                self.request.sendall(icon)
            else:
                baseDic = {"ContentLength":"0"}
                jsonStr = json.dumps(baseDic,separators=(',',':'))
                header = KHeaderStr + jsonStr + kEndStr
                self.request.sendall(header)
        else:
            pass



class TcpServer(ThreadingTCPServer):
    allow_reuse_address = True
    def serve_forever(self):
        self.stopped = False
        while not self.stopped:
            self.handle_request()
        self.server_close()
    def force_stop(self):
        self.stopped = True
        self.sendQUIT()
    def sendQUIT(self):
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        try:
            sock.connect(self.server_address)
            sock.sendall("QUIT")
        finally:
            sock.close()

#######################################################################
def getTCPPort(port):
    global myTCPServer
    currentPort = port
    while True:
        try:
            myTCPServer = TcpServer(('', currentPort),MyTCPHandler)
            break
        except Exception as e:
            currentPort += 1
    return currentPort

def stopTCPServer():
    global myTCPServer
    try:
        myTCPServer.force_stop()
    except Exception as e:
        pass
########################################################
def json_loads_byteified(json_text):
    return _byteify(
        json.loads(json_text, object_hook=_byteify),
        ignore_dicts=True
    )

def _byteify(data, ignore_dicts = False):
    if isinstance(data, unicode):
        return data.encode('utf-8')
    if isinstance(data, list):
        return [ _byteify(item, ignore_dicts=True) for item in data ]
    if isinstance(data, dict) and not ignore_dicts:
        return {
            _byteify(key, ignore_dicts=True): _byteify(value, ignore_dicts=True)
            for key, value in data.iteritems()
        }
    return data]]>
</content>
                                                </script>
                                                <Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" />
                                                <Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" />
                                                <Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" />
                                            </Box>
                                            <Link inputowner="2" indexofinput="2" outputowner="0" indexofoutput="1" />
                                        </Diagram>
                                    </BehaviorKeyframe>
                                </BehaviorLayer>
                                <BehaviorLayer name="UDPServer">
                                    <BehaviorKeyframe name="UDPServer" index="1">
                                        <Diagram>
                                            <Box name="UDPServer" id="2" localization="8" tooltip="UDPServer" x="276" y="77">
                                                <bitmap>media/images/box/box-python-script.png</bitmap>
                                                <script language="4">
                                                    <content>
                                                        <![CDATA[
from SocketServer import ThreadingUDPServer,BaseRequestHandler
import json
import base64
import threading
import socket
import sys
import time
import vision_definitions
try:
    import numpy
    import cv2
except Exception as e:
    pass

myUDPServer = None

connectedAddress = []

alVideo = ALProxy("ALVideoDevice")
alMemory = ALProxy("ALMemory")
alBehaviorManager = ALProxy("ALBehaviorManager")
alMotion = ALProxy("ALMotion")
alPosture = ALProxy("ALRobotPosture")
alTts = ALProxy("ALTextToSpeech")
alAudioPlayer = ALProxy('ALAudioPlayer')
packageManager =  ALProxy("PackageManager")
alVideoRecorder = None
alAudioRecorder = None
try:
    alSpeech = ALProxy('ALAnimatedSpeech')
    alVideoRecorder = ALProxy('ALVideoRecorder')
    alAudioRecorder = ALProxy('ALAudioRecorder')
except Exception as e:
    alSpeech = ALProxy('ALTextToSpeech')

videoSubscriberID = ""
serverPort = 47351
serverIP = ""
videoConnectedHost = ""
sockRecvHeader = "NAOSpy-hsukanbgdo"
sockSendHeader = "NAOSpy-shsuammsoxo"
isRobotics = 0
imageCount = 0
bNewVersion = True
bSendImage = False
bAudioRecording = False
ncid = ""
tags = []
speechIds = []

notiSeparatorStr = "$*$"


class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self)
        reload(sys)
        sys.setdefaultencoding('utf-8')
        global isRobotics
        try:
            audio = ALProxy("ALAudioDevice")
            isRobotics = 1
        except Exception as e:
            audio = None
            isRobotics = 0

    def onLoad(self):
        global speechIds
        speechIds = []

    def onUnload(self):
        global bSendImage,bAudioRecording
        bSendImage = False

        stopUDPServer()

        alVideo.unsubscribe(videoSubscriberID)

        for id in speechIds:
            try:
                alSpeech.stop(id)
            except:
                pass

        if(alVideoRecorder and alVideoRecorder.isRecording()):
            alVideoRecorder.stopRecording()

        if (alAudioRecorder and bAudioRecording):
            alAudioRecorder.stopMicrophonesRecording()
            bAudioRecording = False

    def onInput_onStart(self):
        global videoSubscriberID,tags
        self.getParentTimeline().pause()
        tags = []

        alVideo.setParam(vision_definitions.kCameraSelectID,0)
        subStr = "shiqishanspy"+str(time.time())
        videoSubscriberID = alVideo.subscribe(subStr, 2, 13, 25)

        startUDPServer()

    def onInput_onStop(self):
        self.onUnload()

    def sendNotification(self, p):
        if len(connectedAddress) == 0:
            return

        sock = socket.socket(socket.AF_INET,socket.SOCK_DGRAM)
        try:
            for address in connectedAddress:
                sock.sendto(p,address)
        except Exception as e:
            self.logger.info("Super NAO send notification..:%s error..%s",p,e)
        finally:
            sock.close()

    def onInput_sendBehaviorNotification(self, p):
        runingBehaviors = ""
        for i in p:

            runingBehaviors += i
            runingBehaviors += "$"

        data = "4010" + notiSeparatorStr + runingBehaviors
        self.sendNotification(data)

    def onInput_sendWakeUpNotification(self, p):
        stiffness = "1"
        if not p:
            stiffness = "0"
        data = "4020" + notiSeparatorStr + stiffness
        self.sendNotification(data)

class MyUDPHandler(BaseRequestHandler):

    def handle(self):
        data = self.request[0].strip()
        sock = self.request[1]
        recvDic = {}
        try:
            recvDic = json_loads_byteified(data)
        except Exception as e:
            return
        try:
            header = recvDic["header"]
            targets = recvDic["targets"]

            if not header == sockRecvHeader:
                return

            isLegal = False
            if targets.count("ALL"):
                isLegal = True
            if recvDic.has_key("robotIP"):
                isLegal = True
            if len(serverIP) > 1 and targets.count(serverIP):
                isLegal = True

            if not isLegal:
                self.sendResponseData(sock,{"tag":recvDic["tag"],"header":sockSendHeader,"statusCode":40,"statusMessage":"Connection has been reset"})
                return


        except Exception as e:
            return

        method = recvDic["method"]
        if method == "POST":
            self.handlePOST(recvDic,sock)
        else:
            self.handleGET(recvDic,sock)

    def sendResponseData(self, sock, data):
        try:
            sock.sendto(json.dumps(data,separators=(',',':')),self.client_address)
        except Exception as e:
            pass
    ## GET ###
    def handleGET(self, dic, sock):
        path = dic["path"]
        tag = dic["tag"]
        port = int(dic["recvPort"])
        baseDic = {"tag":tag,"header":sockSendHeader,"statusCode":0,"statusMessage":"OK"}
        outputDic = {}
        if path == "NP--robots-online":
            outputDic = self.getOnlineDic(dic)
        elif path == "NP--behavior-all":
            outputDic = self.getBehaviorsDic()
        elif path == "NP--settings-info":
            outputDic = self.getSettingsDic(dic)
        elif path == "NP--stiffness-info":
            outputDic = self.getStiffnessDic(dic)
        elif path == "NP--speech-setinfo":
            outputDic = self.getSpeechSetDic(dic)
        elif path == "NP--speech-animations":
            outputDic = self.getSpeechAnimationsDic(dic)
        elif path == "NP--recorder-video":
            outputDic = self.getVideoRecorderDic(dic)
        elif path == "NP--audio-loaded":
            outputDic = self.getLoadedAudioDic(dic)
        elif path == "NP--audio-detail":
            outputDic = self.getAudioDetailDic(dic)
        else:
            return

        baseDic.update(outputDic)
        self.sendResponseData(sock,baseDic)
    ## POST ###
    def handlePOST(self, dic, sock):
        global tags,ncid
        path = dic["path"]
        tag = dic["tag"]
        tagStr = self.client_address[0] + str(tag)
        port = int(dic["recvPort"])
        baseDic = {"tag":tag,"header":sockSendHeader,"statusCode":0,"statusMessage":"OK"}

        newNcid = dic["ncid"]
        if ncid != newNcid:
            tags = []
            ncid = newNcid

        if int(tag) >= 10000000:
            if tags.count(tagStr) >=1:
                self.sendResponseData(sock,baseDic)
                return
            else:
                tags.append(tagStr)

        outputDic = {}
        if path == "NP--robots-connect":
            global serverIP,connectedAddress
            serverIP = dic["robotIP"]
            recvPort = int(dic["recvPort"])
            address = (self.client_address[0],recvPort)
            if not connectedAddress.count(address):
                connectedAddress.append(address)
        elif path == "NP--robots-disconnect":
            global connectedAddress
            recvPort = int(dic["recvPort"])
            address = (self.client_address[0],recvPort)
            if connectedAddress.count(address):
                connectedAddress.remove(address)
        elif path == "NP--image--start":
            global videoConnectedHost
            clientHost = self.client_address[0]
            if len(videoConnectedHost) > 0:
                if videoConnectedHost != clientHost:
                    outputDic = {"statusCode":50,"statusMessage":"Camera has been occupied by other devices"}
            else:
                videoConnectedHost = clientHost
                self.startSendImage(clientHost,port)

        elif path == "NP--image--stop":
            global videoConnectedHost
            if videoConnectedHost == self.client_address[0]:
                self.stopSendImage()
                videoConnectedHost = ""
        elif path == "NP--image--changeIndex":
            self.changeCameraIndex(dic)
        elif path == "NP--image--changeResolution":
            self.changeCameraResolution(dic)
        elif path == "NP--motion-set":
            self.setMotion(dic)
        elif path == "NP--motion-posture":
            self.setPosture(dic)
        elif path == "NP--speech-speech":
            self.speechText(dic)
        elif path == "NP--behavior-single":
            self.behaviorManage(dic)
        elif path == "NP--settings-set":
            self.settingManage(dic)
        elif path == "NP--videoRecord-set":
            self.setVideoRecod(dic)
        elif path == "NP--audioRecord-start":
            self.startAudioRecod(dic)
        elif path == "NP--audioRecord-stop":
            self.stopAudioRecod(dic)
        elif path == "NP--package-install":
            self.installPackage(dic)
        elif path == "NP--sound-operate":
            self.soundOpreate(dic)
        else:
            pass

        if int(tag) >= 10000000:
            baseDic.update(outputDic)
            self.sendResponseData(sock,baseDic)

    ###GET ##############################
    def getOnlineDic(self, dic):
        name = "Simulator"
        version = ""
        serverVersion = 21
        bodyId = ""
        if(isRobotics == 1):
            try:
                system = ALProxy("ALSystem")
                name = system.robotName()
                version = system.systemVersion()
                bodyId = alMemory.getData("Device/DeviceList/ChestBoard/BodyId")
            except :
                pass
        tcpPort = alMemory.getData("NAOSPY_TCPPORT")
        data = {"name":name,"version":version,"serverVersion":serverVersion,"isRobot":isRobotics,"tcpPort":tcpPort,"bodyId":bodyId}
        return data

    def getBehaviorsDic(self):
        defaultList = alBehaviorManager.getDefaultBehaviors()
        behaviorList = alBehaviorManager.getInstalledBehaviors()
        runingList = alBehaviorManager.getRunningBehaviors()
        behaviors = ""
        for i in behaviorList:

            isDefault = "N"
            isRuning = "N"
            if defaultList.count(i):
                isDefault = "Y"
            if runingList.count(i):
                isRuning = "Y"
            i += isDefault
            i += isRuning
            behaviors += i
            behaviors += "$"
            if len(behaviors) > 60000:
                break
        return {"behaviors":behaviors}
    def getSettingsDic(self, dic):
        robotName = "Simulator"
        supportLanguage = ""
        version = ""
        isHighVersion = 0
        audioVolume = 0
        speechVolume = 0
        stiffness = 0
        cpuT = 0
        charging = 0
        charge = 0
        autoLife = "disabled"
        if(isRobotics == 1):
            try:
                audio = ALProxy("ALAudioDevice")
                audioVolume = audio.getOutputVolume()
                info = alMotion.getStiffnesses("Body")
                stiffness = info[0]
                speechVolume = alTts.getVolume()*100
            except :
                audioVolume = 0
                stiffness = 0
            try:
                system = ALProxy("ALSystem")
                isHighVersion = 1
                robotName = system.robotName()
                version = system.systemVersion()
            except :
                pass
            try:
                cpuT = alMemory.getData("Device/SubDeviceList/Head/Temperature/Sensor/Value")
                if alMemory.getData("Device/SubDeviceList/Battery/Current/Sensor/Value") >0:
                    charging = 1
                charge =int(alMemory.getData("Device/SubDeviceList/Battery/Charge/Sensor/Value")*100)
            except :
                pass
            try:
                autonomousLife = ALProxy("ALAutonomousLife")
                autoLife = autonomousLife.getState()
            except :
                pass

        currentLanguage = alTts.getLanguage()
        languageList = alTts.getAvailableLanguages()

        for i in languageList:
            supportLanguage += i
            supportLanguage += "$"
        data = {"currentLanguage":currentLanguage,"supportLanguage":supportLanguage,"name":robotName,"isHighVersion":isHighVersion,"stiffness":stiffness,"audioVolume":audioVolume,"CPUT":cpuT,"charging":charging,"charge":charge,"version":version,"autoLife":autoLife,"speechVolume":speechVolume}
        return data

    def getStiffnessDic(self, dic):
        stiffness = 0
        if(isRobotics == 1):
            try:
                info = alMotion.getStiffnesses("Body")
                stiffness = info[0]
            except :
                stiffness = 0
        data = {"stiffness":stiffness}
        return data

    def getSpeechSetDic(self, dic):
        bodyMode = 0
        try:
            animSpeech = ALProxy('ALAnimatedSpeech')
            bodyMode = animSpeech.getBodyLanguageMode()
        except :
            bodyMode = 0
        supportLanguage = ""
        volume = 0
        if(isRobotics == 1):
            try:
                volume = alTts.getVolume()*100
            except :
                volume = 0
        currentLanguage = alTts.getLanguage()
        languageList = alTts.getAvailableLanguages()

        for i in languageList:
            supportLanguage += i
            supportLanguage += "$"
        data = {"currentLanguage":currentLanguage,"supportLanguage":supportLanguage,"volume":volume,"mode":bodyMode}
        return data
    def getSpeechAnimationsDic(self, dic):
        behaviorList = alBehaviorManager.getInstalledBehaviors()
        animations = ""
        for i in behaviorList:
            if i.startswith("animations/"):
                animations += i
                animations += "$"
                if len(animations) > 60000:
                    break
        return {"animations":animations}
    def getVideoRecorderDic(self, dic):
        isRecording = alVideoRecorder.isRecording()
        cameraID = alVideoRecorder.getCameraID()
        colorSpace = alVideoRecorder.getColorSpace()
        frameRate = alVideoRecorder.getFrameRate()
        resolution = alVideoRecorder.getResolution()
        videoFormat = alVideoRecorder.getVideoFormat()
        data = {"isRecording":isRecording,"cameraID":str(cameraID),"colorSpace":str(colorSpace),"frameRate":str(frameRate),"resolution":str(resolution),"videoFormat":str(videoFormat)}
        return data

    def getLoadedAudioDic(self, dic):
        ids = alAudioPlayer.getLoadedFilesIds()
        names = alAudioPlayer.getLoadedFilesNames()
        data = {"ids":ids,"names":names}
        return data
    def getAudioDetailDic(self, dic):
        taskId = int(dic["taskId"])
        volume = alAudioPlayer.getVolume(taskId)
        length = alAudioPlayer.getFileLength(taskId)
        position1 = alAudioPlayer.getCurrentPosition(taskId)
        time.sleep(1.0)
        position2 = alAudioPlayer.getCurrentPosition(taskId)
        playing = "0"
        if position2 > position1:
            playing = "1"
        data = {"taskId":str(taskId),"volume":str(volume),"length":str(length),"position":str(position2),"playing":playing}
        return data
    ###POST  #########################################
    def startSendImage(self, host, port):
        global bSendImage
        if not bSendImage:
            bSendImage = True
            t = threading.Thread(target=self.__class__.sendImage,args=(self, host,port))
            t.setDaemon(True)
            t.start()
    def sendImage(self, host, port):
        global bSendImage
        sock = socket.socket(socket.AF_INET,socket.SOCK_DGRAM)
        bSendImage = True
        while(bSendImage):
            self.sendImageData(sock,host,port)
        if sock:
            sock.close()
    def stopSendImage(self):
        global bSendImage
        bSendImage = False
    def getImageStr(self):
        imageArr = alVideo.getImageRemote(videoSubscriberID)
        image = imageArr[6]
        array=bytearray(image)
        data=numpy.array(array)
        data=data.reshape([imageArr[1],imageArr[0],3])
        param = 95
        resolution = 0
        if int(imageArr[1]) == 240:
            param = 95
            resolution = 1
        elif int(imageArr[1]) == 480:
            param = 90
            resolution = 2
        elif int(imageArr[1]) == 960:
            param = 60
            resolution = 3
        buf = cv2.imencode('.jpg',data,[int(cv2.IMWRITE_JPEG_QUALITY), param])[1]

        #return buf
        return (resolution,imageArr[7],base64.b64encode(buf))

    def sendImageData(self, sock, host, port):
        global imageCount
        (resolution,cameraIndex,imageStr) = self.getImageStr()
        if imageCount > 900000:
            imageCount = 0
        imageCount += 1
        piceSize = 62000
        totalSize = len(imageStr)
        sum = 0
        count = 0
        total = totalSize/piceSize + min(totalSize%piceSize,1)
        while sum < totalSize:
            sendStr = ""
            if sum + piceSize >= totalSize:
                sendStr = imageStr[sum:]
                sum = totalSize
            else:
                sendStr = imageStr[sum:sum+piceSize]
                sum += piceSize
            data = "3000" + notiSeparatorStr + str(resolution) + notiSeparatorStr + str(cameraIndex) + notiSeparatorStr + str(count) + notiSeparatorStr + str(total) + notiSeparatorStr + str(imageCount) + notiSeparatorStr + str(sendStr)
            sock.sendto(data,(host,port))
            count += 1
    def changeCameraIndex(self, dic):
        index = dic["index"]
        id = 0
        if index == "Bottom":
            id = 1
        alVideo.setActiveCamera(id)
    def changeCameraResolution(self, dic):
        resolution = dic["resolution"]
        value = 0
        if resolution == "240P":
            value = 1
        elif resolution == "480P":
            value = 2
        elif resolution == "960P":
            value = 3
        alVideo.setResolution(videoSubscriberID,value)
    def setWalk(self, dic):
        walkX = int(dic["x"])/10.0
        walkY = int(dic["y"])/10.0
        theta = int(dic["thera"])/10.0
        frequency = int(dic["frequency"])/10.0
        alMotion.setWalkTargetVelocity(walkX,walkY,theta,frequency)
    def setHead(self, dic):
        walkX = int(dic["x"])/10.0
        walkY = int(dic["y"])/10.0
        currentYaw = alMotion.getAngles("HeadYaw",False)
        currentPitch = alMotion.getAngles("HeadPitch",False)
        if(walkX>0 and currentPitch[0]<=0.326):
            alMotion.changeAngles("HeadPitch",walkX,0.2)
        elif(walkX<=0 and currentPitch[0]>=-0.445):
            alMotion.changeAngles("HeadPitch",walkX,0.2)
        if(walkY>0 and currentYaw[0]<=2.07):
            alMotion.changeAngles("HeadYaw",walkY,0.2)
        if(walkY<=0 and currentYaw[0]>=-2.07):
            alMotion.changeAngles("HeadYaw",walkY,0.2)
    def setMotion(self, dic):
        key = dic["action"]
        if key == "Move":
            x = int(dic["x"])/10.0
            y = int(dic["y"])/10.0
            frequency = int(dic["frequency"])/10.0
            if bNewVersion:
                alMotion.moveToward(x,y,0.0)
            else:
                alMotion.setWalkTargetVelocity(x,y,0.0,frequency)

        elif key == "Turn":
            thera = int(dic["thera"])/10.0
            frequency = int(dic["frequency"])/10.0
            if bNewVersion:
                alMotion.moveToward(0.0,0.0,thera)
            else:
                alMotion.setWalkTargetVelocity(0.0,0.0,thera,frequency)
        elif key == "Head":
            x = -int(dic["x"])/10.0
            y = int(dic["y"])/10.0
            alMotion.changeAngles("HeadPitch",x,0.2)
            alMotion.changeAngles("HeadYaw",y,0.2)
        elif key == "LShoulder":
            x = -int(dic["x"])/10.0
            y = int(dic["y"])/10.0
            alMotion.changeAngles("LShoulderPitch",x,0.2)
            alMotion.changeAngles("LShoulderRoll",y,0.2)
        elif key == "LElbow":
            x = int(dic["x"])/10.0
            y = int(dic["y"])/10.0
            alMotion.changeAngles("LElbowYaw",x,0.2)
            alMotion.changeAngles("LElbowRoll",y,0.2)
        elif key == "LWrist":
            x = -int(dic["x"])/10.0
            y = -int(dic["y"])/10.0
            if abs(x) >= abs(y):
                alMotion.changeAngles("LWristYaw",x,0.2)
            else:
                alMotion.changeAngles("LWristYaw",y,0.2)
        elif key == "RShoulder":
            x = -int(dic["x"])/10.0
            y = int(dic["y"])/10.0
            alMotion.changeAngles("RShoulderPitch",x,0.2)
            alMotion.changeAngles("RShoulderRoll",y,0.2)
        elif key == "RElbow":
            x = -int(dic["x"])/10.0
            y = int(dic["y"])/10.0
            alMotion.changeAngles("RElbowYaw",x,0.2)
            alMotion.changeAngles("RElbowRoll",y,0.2)
        elif key == "RWrist":
            x = -int(dic["x"])/10.0
            y = -int(dic["y"])/10.0
            if abs(x) >= abs(y):
                alMotion.changeAngles("RWristYaw",x,0.2)
            else:
                alMotion.changeAngles("RWristYaw",y,0.2)
        elif key == "handSet":
            hand = dic["hand"]
            if hand == "lhand_close":
                alMotion.post.closeHand("LHand")
            elif hand == "lhand_open":
                alMotion.post.openHand("LHand")
            elif hand == "rhand_close":
                alMotion.post.closeHand("RHand")
            elif hand == "rhand_open":
                alMotion.post.openHand("RHand")

    def setPosture(self, dic):
        posture = dic["posture"]
        alPosture.setMaxTryNumber(2)
        alPosture.goToPosture(posture,0.7)
    def speechText(self, dic):
        global speechIds
        message = dic["message"]
        sentence = "\RSPD="+ str( 100 ) + "\ "
        sentence += "\VCT="+ str( 100 ) + "\ "
        sentence += str(message)
        sentence +=  "\RST\ "
        id = alSpeech.post.say(str(sentence))
        speechIds.append(id)
        alSpeech.wait(id, 0)
    def behaviorManage(self, dic):
        command = dic["command"]
        behavior = dic["behavior"]
        if(command == "start"):
            alBehaviorManager.post.runBehavior(behavior)
        elif(command == "stop"):
            if (alBehaviorManager.isBehaviorRunning(behavior)):
                alBehaviorManager.stopBehavior(behavior)
        elif(command == "add"):
            alBehaviorManager.addDefaultBehavior(behavior)
        elif(command == "remove"):
            alBehaviorManager.removeDefaultBehavior(behavior)
    def settingManage(self, dic):
        key = dic["key"]
        value = dic["value"]
        if(key == "stiffness"):
            alMotion.post.stiffnessInterpolation("Body",float(value)/1.0, 0.2)
        elif(key == "audioVolume"):
            try:
                audio = ALProxy("ALAudioDevice")
                audio.setOutputVolume(int(value))
            except:
                pass
        elif(key == "speechVolume"):
             alTts.setVolume(int(value)/100.0)
        elif(key == "speechAnimated"):
            try:
                animSpeech = ALProxy('ALAnimatedSpeech')
                animSpeech.setBodyLanguageMode(int(value))
            except:
                pass
        elif(key == "speechLanguage"):
            alTts.setLanguage(value)
        elif(key == "autoLife"):
            try:
                autonomousLife = ALProxy("ALAutonomousLife")
                autonomousLife.setState(value)
            except:
                pass
        elif(key == "system"):
            try:
                system = ALProxy("ALSystem")
                if(value == "Reboot"):
                    system.reboot()
                elif(value == "Shut Down"):
                    system.shutdown()
            except:
                pass
    def setVideoRecod(self, dic):
        action = dic["action"]
        if action == "stop":
            alVideoRecorder.stopRecording()
        elif action == "start":
            name = dic["name"]
            if not alVideoRecorder.isRecording():
                alVideoRecorder.startRecording("/home/nao/recordings/cameras/",name,True)
        elif action == "resolution":
            resolution = dic["resolution"]
            alVideoRecorder.setResolution(int(resolution))
        elif action == "camera":
            camera = dic["camera"]
            alVideoRecorder.setCameraID(int(camera))
        elif action == "rate":
            rate = dic["rate"]
            alVideoRecorder.setFrameRate(int(rate))
        elif action == "format":
            format = dic["format"]
            alVideoRecorder.setVideoFormat(format)
        elif action == "space":
            space = dic["space"]
            colorSapce = 13
            if space == "Yuv":
                colorSapce = 0
            alVideoRecorder.setColorSpace(colorSapce)

    def startAudioRecod(self, dic):
        path = "/home/nao/recordings/microphones/"
        if not os.path.exists(path):
            os.makedirs(path)
        name = path + dic["name"]
        front = int(dic["front"])
        rear = int(dic["rear"])
        left = int(dic["left"])
        right = int(dic["right"])
        channel = (left,right,front,rear)
        alAudioRecorder.startMicrophonesRecording(name,dic["format"],int(dic["rate"]),channel)

    def stopAudioRecod(self, dic):
        alAudioRecorder.stopMicrophonesRecording()

    def installPackage(self, dic):
        name = dic["name"]
        packageManager.install(name)

    def soundOpreate(self, dic):
        key = dic["key"]
        if key == "stateControl":
            taskId = int(dic["taskId"])
            value = dic["value"]
            if value == "play":
                alAudioPlayer.post.play(taskId)
            elif value == "playLoop":
                alAudioPlayer.post.playInLoop(taskId)
            elif value == "pause":
                alAudioPlayer.pause(taskId)
        elif key == "volume":
            taskId = int(dic["taskId"])
            value = float(dic["value"])
            alAudioPlayer.setVolume(taskId,value)
        elif key == "goto":
            taskId = int(dic["taskId"])
            value = float(dic["value"])
            alAudioPlayer.goTo(taskId,value)
        elif key == "load":
            name = dic["name"]
            if 0 == alAudioPlayer.getLoadedFilesNames().count(name):
                alAudioPlayer.loadFile(name)
        elif key == "stopall":
            alAudioPlayer.stopAll()
        elif key == "ftp_play":
            name = dic["name"]
            if 0 == alAudioPlayer.getLoadedFilesNames().count(name):
                taskId = alAudioPlayer.loadFile(name)
                alAudioPlayer.post.play(taskId)
            else:
                index = alAudioPlayer.getLoadedFilesNames().index(name)
                taskId = alAudioPlayer.getLoadedFilesIds()[index]
                alAudioPlayer.post.play(int(taskId))
##################################################
class UdpServer(ThreadingUDPServer):
    allow_reuse_address = True
    def serve_forever(self):
        self.stopped = False
        while not self.stopped:
            self.handle_request()
        self.server_close()
    def force_stop(self):
        self.stopped = True
        self.sendQUIT()
    def sendQUIT(self):
        sock = socket.socket(socket.AF_INET,socket.SOCK_DGRAM)
        try:
            sock.sendto("QUIT",self.server_address)
        finally:
            sock.close()

#######################################################################
def startUDPServer():
    global myUDPServer
    myUDPServer = UdpServer(('', serverPort),MyUDPHandler)
    myUDPServer.serve_forever()

def stopUDPServer():
    global myUDPServer
    try:
        myUDPServer.force_stop()
    except Exception as e:
        pass

########################################################
def json_loads_byteified(json_text):
    return _byteify(
        json.loads(json_text, object_hook=_byteify),
        ignore_dicts=True
    )

def _byteify(data, ignore_dicts = False):
    if isinstance(data, unicode):
        return data.encode('utf-8')
    if isinstance(data, list):
        return [ _byteify(item, ignore_dicts=True) for item in data ]
    if isinstance(data, dict) and not ignore_dicts:
        return {
            _byteify(key, ignore_dicts=True): _byteify(value, ignore_dicts=True)
            for key, value in data.iteritems()
        }
    return data]]>
</content>
                                                </script>
                                                <Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" />
                                                <Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" />
                                                <Input name="sendBehaviorNotification" type="0" type_size="1" nature="1" inner="0" tooltip="" id="3" />
                                                <Input name="sendWakeUpNotification" type="0" type_size="1" nature="1" inner="0" tooltip="" id="4" />
                                                <Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="5" />
                                            </Box>
                                            <Box name="BehaviorEvent" id="5" localization="8" tooltip="Subscribes to a signal on a NAOqi2 service, or an event in NAOqi&apos;s shared memory&#x0A;When subscribed, the output will be triggered every time the signal is emitted or the event is raised." x="110" y="98">
                                                <bitmap>media/images/box/sensors/STM.png</bitmap>
                                                <script language="4">
                                                    <content>
                                                        <![CDATA[class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self)
        pass

    def onLoad(self):
        import threading
        self.lock = threading.RLock()
        self.signal = None
        self.linkId = -1

    def onUnload(self):
        with self.lock:
            self.unsubscribe()

    def onInput_onStart(self):
        with self.lock:
            self.unsubscribe()
            event = self.getParameter("event")

            if(len(event) == 0):
                return

            params = event.split(".")
            if(len(params) == 2):
                try:
                    self.signal = getattr(self.session().service(params[0]), params[1])
                except Exception as e:
                    mem = self.session().service("ALMemory")
                    if(event in mem.getEventList()):
                        self.signal = mem.subscriber(event).signal
                    else:
                        return
            else:
                try:
                    self.signal = self.session().service("ALMemory").subscriber(event).signal
                    self.linkId = self.signal.connect(self.reemitSignal)
                except Exception as e:
                    pass



    def onInput_onStop(self):
        with self.lock:
            self.unsubscribe()
            self.onStopped()

    def unsubscribe(self):
        if(self.signal is not None and self.linkId != -1):
            self.signal.disconnect(self.linkId)

        del self.signal
        self.signal = None
        self.linkId = -1

    def reemitSignal(self, *args):
        if(len(args) == 0):
            self.onEvent()
        elif(len(args) == 1):
            self.onEvent(args[0])
        else:
            self.onEvent(args)]]>
</content>
                                                </script>
                                                <Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" />
                                                <Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="When this input is activated, the box will try to subscribe to the signal or the event passed in the box parameter.&#x0A;&#x0A;If it is retriggered and the parameter has changed, the box will undo the previous subscription and subscribe to the new signal or the new event." id="2" />
                                                <Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Stop the box and cancel the subscription, if any." id="3" />
                                                <Output name="onEvent" type="0" type_size="1" nature="2" inner="0" tooltip="This output is triggered each time the signal/event to which the box is connected is emitted/raised. It will carry the payload associated with the signal emission/event raise." id="4" />
                                                <Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="Signal sent when box behavior is finished." id="5" />
                                                <Output name="onError" type="3" type_size="1" nature="1" inner="0" tooltip="This output is triggered when the box encounters an error, and contains the error message." id="6" />
                                                <Parameter name="event" inherits_from_parent="0" content_type="3" value="BehaviorsRun" default_value="" custom_choice="0" tooltip='This parameter describes the signal to connect to, and the service advertising this signal.&#x0A;&#x0A;Use the pattern &quot;Service.Signal&quot; to connect to a signal, or the event key to connect to an event.' id="7" />
                                            </Box>
                                            <Box name="WakeUpEvent" id="1" localization="8" tooltip="Subscribes to a signal on a NAOqi2 service, or an event in NAOqi&apos;s shared memory&#x0A;When subscribed, the output will be triggered every time the signal is emitted or the event is raised." x="115" y="233">
                                                <bitmap>media/images/box/sensors/STM.png</bitmap>
                                                <script language="4">
                                                    <content>
                                                        <![CDATA[class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self)
        pass

    def onLoad(self):
        import threading
        self.lock = threading.RLock()
        self.signal = None
        self.linkId = -1

    def onUnload(self):
        with self.lock:
            self.unsubscribe()

    def onInput_onStart(self):
        with self.lock:
            self.unsubscribe()
            event = self.getParameter("event")

            if(len(event) == 0):
                return

            params = event.split(".")
            if(len(params) == 2):
                try:
                    self.signal = getattr(self.session().service(params[0]), params[1])
                except Exception as e:
                    mem = self.session().service("ALMemory")
                    if(event in mem.getEventList()):
                        self.signal = mem.subscriber(event).signal
                    else:
                        return
            else:
                try:
                    self.signal = self.session().service("ALMemory").subscriber(event).signal
                    self.linkId = self.signal.connect(self.reemitSignal)
                except Exception as e:
                    pass



    def onInput_onStop(self):
        with self.lock:
            self.unsubscribe()
            self.onStopped()

    def unsubscribe(self):
        if(self.signal is not None and self.linkId != -1):
            self.signal.disconnect(self.linkId)

        del self.signal
        self.signal = None
        self.linkId = -1

    def reemitSignal(self, *args):
        if(len(args) == 0):
            self.onEvent()
        elif(len(args) == 1):
            self.onEvent(args[0])
        else:
            self.onEvent(args)]]>
</content>
                                                </script>
                                                <Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" />
                                                <Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="When this input is activated, the box will try to subscribe to the signal or the event passed in the box parameter.&#x0A;&#x0A;If it is retriggered and the parameter has changed, the box will undo the previous subscription and subscribe to the new signal or the new event." id="2" />
                                                <Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Stop the box and cancel the subscription, if any." id="3" />
                                                <Output name="onEvent" type="0" type_size="1" nature="2" inner="0" tooltip="This output is triggered each time the signal/event to which the box is connected is emitted/raised. It will carry the payload associated with the signal emission/event raise." id="4" />
                                                <Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="Signal sent when box behavior is finished." id="5" />
                                                <Output name="onError" type="3" type_size="1" nature="1" inner="0" tooltip="This output is triggered when the box encounters an error, and contains the error message." id="6" />
                                                <Parameter name="event" inherits_from_parent="0" content_type="3" value="robotIsWakeUp" default_value="" custom_choice="0" tooltip='This parameter describes the signal to connect to, and the service advertising this signal.&#x0A;&#x0A;Use the pattern &quot;Service.Signal&quot; to connect to a signal, or the event key to connect to an event.' id="7" />
                                            </Box>
                                            <Link inputowner="2" indexofinput="2" outputowner="0" indexofoutput="1" />
                                            <Link inputowner="5" indexofinput="2" outputowner="0" indexofoutput="1" />
                                            <Link inputowner="2" indexofinput="3" outputowner="5" indexofoutput="4" />
                                            <Link inputowner="1" indexofinput="2" outputowner="0" indexofoutput="1" />
                                            <Link inputowner="2" indexofinput="4" outputowner="1" indexofoutput="4" />
                                        </Diagram>
                                    </BehaviorKeyframe>
                                </BehaviorLayer>
                            </Timeline>
                        </Box>
                        <Link inputowner="3" indexofinput="2" outputowner="0" indexofoutput="2" />
                    </Diagram>
                </BehaviorKeyframe>
            </BehaviorLayer>
        </Timeline>
    </Box>
</ChoregrapheProject>
